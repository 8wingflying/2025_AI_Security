# -*- coding: utf-8 -*-
"""Transformer_imdb_20251030.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N2UvbjyDzLp3m24FnBkv3Q1yDkx0ob46
"""

import tensorflow as tf
from tensorflow.keras import layers
from tensorflow.keras.datasets import imdb
from tensorflow.keras.preprocessing.sequence import pad_sequences
import matplotlib.pyplot as plt

# è¶…åƒæ•¸è¨­å®š
vocab_size = 10000
maxlen = 200
embedding_dim = 64

# è¼‰å…¥ IMDB è³‡æ–™
(x_train, y_train), (x_test, y_test) = imdb.load_data(num_words=vocab_size)

x_train = pad_sequences(x_train, maxlen=maxlen)
x_test = pad_sequences(x_test, maxlen=maxlen)

# ğŸ§± 2. å»ºç«‹ Transformer Encoder æ¨¡çµ„
# è‡ªå®šç¾© Multi-Head Self-Attention æ¨¡çµ„
class TransformerEncoder(layers.Layer):
    def __init__(self, embed_dim, num_heads, ff_dim, rate=0.1):
        super(TransformerEncoder, self).__init__()
        self.att = layers.MultiHeadAttention(num_heads=num_heads, key_dim=embed_dim)
        self.ffn = tf.keras.Sequential([
            layers.Dense(ff_dim, activation="relu"),
            layers.Dense(embed_dim)
        ])
        self.layernorm1 = layers.LayerNormalization(epsilon=1e-6)
        self.layernorm2 = layers.LayerNormalization(epsilon=1e-6)
        self.dropout1 = layers.Dropout(rate)
        self.dropout2 = layers.Dropout(rate)

    def call(self, inputs, training):
        attn_output = self.att(inputs, inputs)
        attn_output = self.dropout1(attn_output, training=training)
        out1 = self.layernorm1(inputs + attn_output)
        ffn_output = self.ffn(out1)
        ffn_output = self.dropout2(ffn_output, training=training)
        return self.layernorm2(out1 + ffn_output)

# ğŸ§® 3. å»ºç«‹ Transformer æ¨¡å‹
embed_dim = 64   # Embedding å‘é‡ç¶­åº¦
num_heads = 2    # æ³¨æ„åŠ›é ­æ•¸
ff_dim = 64      # Feed-Forward ç¶²è·¯ç¶­åº¦

inputs = layers.Input(shape=(maxlen,))
embedding_layer = layers.Embedding(vocab_size, embed_dim)(inputs)

# åŠ å…¥ä½ç½®ç·¨ç¢¼ (Positional Encoding)
positions = tf.range(start=0, limit=maxlen, delta=1)
positions = layers.Embedding(input_dim=maxlen, output_dim=embed_dim)(positions)
x = embedding_layer + positions

# åŠ å…¥ Transformer Encoder
encoder = TransformerEncoder(embed_dim, num_heads, ff_dim)
x = encoder(x, training=True) # Pass the training argument here

# Global Average Pooling + Dense
x = layers.GlobalAveragePooling1D()(x)
x = layers.Dropout(0.3)(x)
x = layers.Dense(64, activation="relu")(x)
x = layers.Dropout(0.3)(x)
outputs = layers.Dense(1, activation="sigmoid")(x)

model = tf.keras.Model(inputs=inputs, outputs=outputs)
model.compile(optimizer="adam", loss="binary_crossentropy", metrics=["accuracy"])

model.summary()

# ğŸ§  4. æ¨¡å‹è¨“ç·´èˆ‡è©•ä¼°
history = model.fit(x_train, y_train,
                    validation_split=0.2,
                    epochs=5,
                    batch_size=64)

loss, acc = model.evaluate(x_test, y_test)
print(f"æ¸¬è©¦æº–ç¢ºç‡ï¼š{acc:.3f}")

# ğŸ“ˆ 5. è¨“ç·´çµæœè¦–è¦ºåŒ–
plt.figure(figsize=(10,4))
plt.subplot(1,2,1)
plt.plot(history.history['accuracy'], label='train_acc')
plt.plot(history.history['val_accuracy'], label='val_acc')
plt.title('æº–ç¢ºç‡')
plt.legend()

plt.subplot(1,2,2)
plt.plot(history.history['loss'], label='train_loss')
plt.plot(history.history['val_loss'], label='val_loss')
plt.title('æå¤±å‡½æ•¸')
plt.legend()
plt.show()